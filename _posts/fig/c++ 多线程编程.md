# c++ 多线程 & 多进程

（8.15）

### 1. 基本概念

- **进程（Process）**：

  - 进程是操作系统分配资源的基本单位。它是一个独立的执行环境，包括程序的代码、数据、打开的文件、内存空间、寄存器状态等。
  - 每个进程在自己的地址空间中运行，相互之间独立，进程之间通常需要通过进程间通信（IPC）来交换数据。
  - 进程有自己的独立地址空间，因此进程之间的数据不共享，但进程切换的开销较大。

  > 父进程、子进程
  >
  > - 孤儿进程：父进程结束，子进程还在进行
  > - 僵尸进程：父进程没有调用wt() 或 wtpid() 系统调用取得子进程的终止状态，子进程的进程描述符仍在系统中占用资源

  - 进程**状态**（PCB 进程控制块）
    - 创建
    - 就绪
    - 执行
    - 阻塞
    - 终止

- **线程（Thread）**：

  - 线程是在进程内部运行的轻量级执行单元，一个进程可以包含多个线程。
  - 线程共享进程的地址空间和资源，包括代码段、全局变量、打开文件等。
  - 线程之间的通信更容易，因为它们共享相同的内存空间，但需要谨慎处理线程间的竞争条件。

- **协程（Coroutine）**：

  - 协程是一种轻量级的线程，可以看作是在用户级别上的线程，不依赖于操作系统线程。
  - 协程可以在同一个线程内执行，切换成本较低，通常不涉及操作系统级别的调度。
  - 协程是协作式多任务的一种形式，由程序员显式地进行协程切换。
  - 协程常用于编写高效的异步代码，如异步IO操作、事件驱动编程等。

- **进程 VS 线程 VS 协程**

  - 进程：
    - 操作系统资源调度和分配的基本单位
    - 一个进程可以有多个线程
    - 某个进程崩溃不会影响其他进程
    - 有独立的存储单元
    - 进程切换系统开销大
    - 并发性较低
  - 线程
    - 操作系统可执行的最小调度和分配单位，CPU调度的基本单位
    - 一个线程崩溃会让进程崩溃（存疑 =》JVM）
    - 共享进程的内存，
    - 先蹭你切换开销比进程小，
    - 自身只有栈和寄存器等少量的独立空间
    - 并发性较高
  - 协程
    - 靠编译语言实现，用户态线程。创建不需要调用操作系统功能，协程璧线程轻量很多。
    - 线程多核环境下是能够并行的，协程是为并发而产生的
    - 线程进程是同步机制，协程是异步的
    - 线程是抢占式的，协程是非抢占式的。同一时间只有一个协程拥有使用权。
    - 线程数量在千量级，协程可以达到上万。

---

#### 1.1 进程通信方式

- 管道（无名管道）：
  - 实质：内存缓冲区
  - 具有亲缘关系的进程间通信（相关进程间通信）
- 命名管道（FIFO）：
  - 增加一个路径名的关联，访问FIFO文件路径
  - 能用于没有亲缘关系的进程间通信
- **信号（Signal）**：
  - 信号是一种轻量级的通信方式，允许一个进程向另一个进程发送异步通知。
  - 信号通常用于处理异常情况、中断和事件处理。
- 消息队列（**Message Queue**）：进程间的异步通信
  - 写进程
  - 读进程
- **共享内存（Shared Memory）**：
  - 共享内存是一种高效的通信方式，允许不同进程在它们的地址空间中共享一块内存区域。
  - 这意味着进程可以直接读写共享内存，而无需进行复制或传输数据，因此速度较快。
  - 但需要谨慎处理**竞争条件和同步问题**，以确保数据的完整性。
- **套接字（Socket）**：
  - 套接字通常用于网络编程，但也可以用于进程间通信，特别是在不同主机上。
  - 套接字提供了一种灵活的方式来实现进程之间的通信，包括TCP和UDP套接字。
- 内存映射
  - 将磁盘内容映射到内存，
- 信号量（PV操作）
- **文件锁（File Lock）**：
  - 文件锁允许多个进程协调对共享文件的访问，以防止数据竞争。
  - 进程可以使用文件锁来协调对文件的读取和写入操作。

#### 1.2 线程通信方式

- 共享内存
  - 初始化数据端
  - 未初始化数据段
  - 堆内存段
- 锁 
  - 线程间的同步互斥
    - **互斥锁（Mutex）**：只能有一个线程访问共享资源  =》 悲观锁
      - 互斥锁是最常见的锁类型，用于保护共享资源，确保一次只有一个线程可以访问它。互斥锁通常是操作系统提供的原语，可以用于保护临界区域。
    - **读写锁（Read-Write Lock）**：
      - 读写锁允许多个线程同时读取共享资源，但**只允许一个线程写入资源**。这提高了并发性，特别适用于读操作远远多于写操作的情况。
    - **自旋锁（Spin Lock）**：
      - 自旋锁是一种锁，它在尝试获取锁失败时会一直循环（自旋），而不是将线程阻塞。**自旋锁适用于短时间内可以获取到锁的情况，避免了线程切换的开销。**
    - **递归锁（Recursive Lock）**：
      - 递归锁允许同一线程多次获取同一个锁，而不会导致死锁。它在递归函数中对同一资源进行多次锁定时很有用。
- `pthread_kill()` 的主要作用是向目标线程发送一个信号，常见的用途包括：
  - **线程终止（Thread Termination）**：通过发送 `SIGTERM` 或 `SIGINT` 信号，可以请求目标线程优雅地退出。
  - **线程间通信（Thread Communication）**：可以自定义信号处理程序，以在线程间进行简单的通信，例如通知一个线程执行某个操作。
- 条件变量（原子方式）+ 互斥锁
- **信号量（Semaphore）**：
  - 信号量是一个计数器，用于控制多个线程对共享资源的访问。它可以用于限制同时访问资源的线程数量，也可以用于线程同步。

#### 1.3 锁

- 并发访问控制两种不同策略

  - **悲观锁（Pessimistic Locking）**：
    - 悲观锁假设在访问共享资源时会发生竞争和冲突。因此，它在进程或线程访问共享资源之前，会先获取锁，阻止其他进程或线程同时访问该资源。
    - 典型的悲观锁是互斥锁，例如互斥量（Mutex）或读写锁，它们确保同一时间只有一个线程能够修改共享资源，其他线程必须等待锁的释放。
    - 悲观锁通常适用于对共享资源进行频繁写入操作的情况，但可能会引入性能开销，因为锁定的时候其他线程无法访问资源。
  - **乐观锁（Optimistic Locking）**：
    - 乐观锁假设并发冲突的发生是不常见的，因此它允许多个进程或线程同时访问共享资源而不阻塞它们。只在数据准备更新时才会检查是否有冲突。
    - 典型的乐观锁是版本控制或时间戳（Timestamp）机制。每次修改共享资源时，将版本号或时间戳更新，当其他进程或线程尝试修改时，检查版本号或时间戳是否匹配，如果不匹配，说明有冲突。
    - 乐观锁通常适用于读操作频繁且冲突较少的情况，减少了锁定资源的时间，但可能需要额外的冲突检测和处理。

  > - 悲观锁适用于对共享资源的写操作频繁，且有较高的并发冲突可能性的情况，但可能引入性能开销和竞争。
  > - 乐观锁适用于读操作频繁，且冲突不太频繁的情况，可以提高性能，但需要额外的冲突检测和处理。

- **互斥锁（Mutex）**：

  - 互斥锁是最常见的锁类型，用于保护共享资源，确保一次只有一个线程可以访问它。互斥锁通常是操作系统提供的原语，可以用于保护临界区域。

- **读写锁（Read-Write Lock）**：

  - 读写锁允许多个线程同时读取共享资源，但只允许一个线程写入资源。这提高了并发性，特别适用于读操作远远多于写操作的情况。

- **自旋锁（Spin Lock）**：

  - 自旋锁是一种锁，它在尝试获取锁失败时会一直循环（自旋），而不是将线程阻塞。自旋锁适用于短时间内可以获取到锁的情况，避免了线程切换的开销。

- **分布式锁（Distributed Lock）**：

  - 分布式锁用于在分布式系统中控制对共享资源的访问。它们确保在不同节点上的不同线程或进程之间进行协调。

- **递归锁（Recursive Lock）**：

  - 递归锁允许同一线程多次获取同一个锁，而不会导致死锁。它在递归函数中对同一资源进行多次锁定时很有用。

- **文件锁（File Lock）**：

  - 文件锁允许多个进程协调对共享文件的访问，以防止数据竞争。进程可以使用文件锁来协调对文件的读取和写入操作。

### 2. 基本操作

- **join() 方法**： 当您创建一个线程并调用其 `join()` 方法时，主线程会等待该线程完成执行，然后再继续执行下一步操作。这意味着主线程将阻塞，直到被 `join()` 的线程执行完毕。这通常用于等待工作线程完成并获取其结果。

```c++
cppCopy code
void threadFunction() {
    // Some thread work
}

int main() {
    std::thread t(threadFunction);
    t.join(); // 主线程等待 t 完成
    return 0;
}
```

在上面的示例中，主线程等待线程 `t` 完成，然后继续执行 `return 0;`。

- **detach() 方法**： 调用 `detach()` 方法将分离线程，意味着主线程和子线程之间的连接被切断。分离线程不再与主线程同步，主线程可以继续执行，而不需要等待分离的线程完成。分离的线程在执行完毕后，其资源会被自动回收。

```c++
cppCopy code
void threadFunction() {
    // Some thread work
}

int main() {
    std::thread t(threadFunction);
    t.detach(); // 分离线程 t
    return 0;
}
```

