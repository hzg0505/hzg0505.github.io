---
title: Redis
date: 2023-09-24 15:30:00 +0800
categories: [学习笔记, 后端]
# toc: false
tags: [Redis, 数据库]     # TAG names should always be lowercase

---

# Build Your Own Redis with C/C++

### 1. 前言

- Redis
  - 网络编程
    - event loop
    - protocols
    - timers
  - 数据结构



### 2. socket 编程

![img](https://book.itheima.net/uploads/course/images/c/4.10/image-20200630132255915.png)

#### 1. socket()

```c
#include <sys/socket.h>

int socket(int domain, int type, int protocol);
```

- 函数功能：创建套接字，类似打开文件 open 操作，此方法返回一个文件描述符，用于网络中收发数据
- 参数
  - domain
    - AF_INET   因特网，IPv4
    - AF_UNIX  本地进程，本地系统
  - type
    - SOCK_STREAM     TCP 协议 （可靠传输）
    - SOCK_DGRAM     UDP 协议 （不可靠传输）
    - SOCK_RAW          ICMP 协议（单一网络反问，一般永无开发人员需自行设置数据报格式或参数）
  - protocol
    - 0 ：默认协议

- 返回值
  - 创建失败返回 -1 设置 errno

#### 2. bind()  ---  server端

```c
#include <sys/socket.h>

int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);
```

- 函数功能：用于服务端，服务端的socket文件绑定一个进程，“主机号+端口号” 可标识网络中的唯一进程。（绑定服务器中的socket与网络中的一个进程地址）
- sockfd： socket 文件描述符
- sockaddr：端口号和地址
  - `INADDR_ANY` ： 表示服务器可以接受任何来自该网络接口的IP地址的连接
  - `htonl` ：表示 host to network long，它用于将主机字节顺序的无符号长整数转换为网络字节顺序的无符号长整数。
  - `htons` :   表示 host to network short，它用于将主机字节顺序的无符号短整数转换为网络字节顺序的无符号短整数。
- addrlen：参数addr的长度

```c++
struct sockaddr{
	sa_family_t sa_familly;
  char  sa_data[14];    // 地址
}; 

struct sockaddr_in servaddr;                  //结构体定义
bzero(&servaddr, sizeof(servaddr));           //结构体清零
servaddr.sin_family = AF_INET;                //设置地址类型为AF_INET
servaddr.sin_addr.s_addr = htonl(INADDR_ANY); //设置网络地址为INADDR_ANY
// inet_pton(AF_INET, "192.168.0.1", &(servaddr.sin_addr)); //设置网络地址为192.168.0.1 
servaddr.sin_port = htons(85);                //设置端口号为85
```

- 返回值
  - 调用成功返回0
  - 失败返回-1 设置 errno



#### 3. listen()   --- server 端

```c
#include <sys/socket.h>
int listen(int sockfd, int backlog);
```

- 功能： 绑定的 socket 监听客户端进程状态，接收连接请求

- 参数
  - sockfd：socket 文件描述符
  - backlog：设置请求队列的最大长度 （限制连接数量）
    - accept() 会接受连接，当连接过多（>backlog) 时，忽略连接请求
- 返回值
  - 成功返回0
  - 失败返回-1，设置errno

#### 4. accept()  --- server 端

```c
#include <sys/socket.h>
int accept(int sockfd, struct sockaddr * addr, socklen_t *addrlen);
```

- 功能：该函数用于从已完成连接队列（已完成三次握手）中取出连接，并创建一个新的 socket 用于和客户端通信。如果队列为空，则阻塞等待连接。
- 参数
  - sockfd：socket 文件描述符
  - addr：客户端地址，如果设置为NULL，表示不关心客户端的地址
  - addrlen：
    - 传入：函数调用者提供的缓存区addr的长度
    - 传出：客户端地址结构体的实际长度
- 返回值：
  - 如果 accept 函数成功，它将返回一个新的 socket 描述符，该描述符可以用于和客户端进行通信。
  - 如果发生错误，则返回 -1。

#### 5. connect --- client 端

```c
#include <sys/socket.h>
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

- 功能：向服务器发起连接请求。
- 参数：
  - sockfd： socket 文件描述符
  - sockaddr：端口号和地址
  - addrlen：

- 返回值

  - 调用成功返回0

  - 失败返回-1 设置 errno



#### 6. send()

```c
#include <sys/socket.h>
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
```

- 功能：向处于连接状态的套接字中发送数据
- 参数
  - sockfd：套接字文件描述符
  - buf：发送数据缓存区指针
  - len：buf 长度
  - flags：执行方式（阻塞/非阻塞）
    - flags=0时可使用 write()函数替代 send() 函数
- 相关api
  - sendto、sendmsg、

```c
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
           const struct sockaddr *dest_addr, socklen_t addrlen);
ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
```

- sendto()函数中的前4个参数与send()函数的参数相同，之后的参数dest_addr和addrlen分别用于设置接收数据进程的地址和地址的长度；sendmsg()函数中的第二个参数msg为struct msghdr类型的结构体指针，该参数用于传入目标进程的地址、地址的长度等信息。

#### 7. recv()

```c
#include <sys/socket.h>
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
```

- 功能：从已连接的套接字中接收信息
- 参数
  - sockfd：套接字文件描述符
  - buf：接收数据缓存区指针
  - len：buf 长度
  - flags：执行方式（阻塞/非阻塞）
    - flags=0时可使用 write()函数替代 read() 函数
- 返回值
  - 成功 返回读到的字节数
  - 失败返回 -1，并设置errno
- 相关函数：
  - read()函数、
  - recvfrom()函数
  - recvmsg()函数

#### 8. close()

```c
#include <unistd.h>
int close(int fd);
```

- 功能：close()函数用于释放系统分配给套接字的资源，该函数即文件操作中常用于关闭文件的函数。
- 返回值
  - 调用成功返回 0
  - 调用失败返回 -1 ，并设置 errno





### 3. 网络编程原理

#### 1. fd（socket 文件描述符）

- 虽然文件描述符只是一个整数，但它实际上是一个**句柄（handle）**，用于在操作系统中标识和访问具体的套接字资源。当创建一个套接字时，操作系统会为其分配一个文件描述符。这个文件描述符可以用于在后续的系统调用中标识该套接字。

- 文件描述符本身并不直接包含套接字的细节信息，它只是一个用于访问套接字的句柄。然而，可以通过使用不同的系统调用来获取和设置套接字的详细信息。例如，使用 getsockopt() 和 setsockopt() 系统调用可以获取和设置套接字的选项信息，如接收缓冲区大小、发送缓冲区大小等。



### 3. redis 与网络编程

- redis 是一个 服务/客户 系统，多用户一个服务。
- server 接受 TCP 请求
- fd（文件描述副） 是一个整数，它引用 Linux 内核中的某些内容，例如 TCP 连接、磁盘文件、侦听端口或其他一些资源等。









# redis

> redis 单线程为什么这么快







### 1. 什么是redis

- 远程字典服务（remote dictionary service）分布式缓存
- 内存数据库，数据结构数据库，key-value 数据库
  - 内存数据库，操作数据都是操作内存
  - 数据结构高效
    - 数据组织：
      - 动态的数据结构来组织所有的数据
      - 动态扩缩容，渐进式 rehash



- redis 线程
  - redis-server : 处理网络命令
  - jemalloc_bg_thd: 内存池
  - bio_close_file：关闭文件是一种阻塞 io，
    - 内存数据持久化  => rdb  
      - 复制一个redis进程，将数据写入rdb，通过信号通知redis进程
  - bio_aof_fsync：数据刷盘
    - 抛给其他线程进行数据持久化
      - 不想在redis进程中进行处理，将数据刷盘到 aof 文件中
  - bio_lazy_free：用于