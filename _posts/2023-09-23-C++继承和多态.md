---
title: c++面向对象
date: 2023-09-21 15:30:00 +0800
categories: [学习笔记, c++]
# toc: false
tags: [c++, 面向对象]     # TAG names should always be lowercase
---



#  继承

![image-20230923204357135](/Users/asic-mbp/Library/Application Support/typora-user-images/image-20230923204357135.png)

### 1. 继承

- 代码重用
  - c语言中重用：拷贝代码、修改代码
  - c++：**组合**或**继承**已有类
    - 组合：将一个类作为一个类的对象成员
- 继承
  - 从已编写好的类来创建新类
  - 新类中具有原有类所有的属性和操作
  - 可以在原有类的基础上做一些修改和增补
  - 新类称为**派生类**或**子类**，原有类称为**基类**或父类
  - 派生类是基类的具体化
- 语法

```c++
class 派生类名：继承方式 基类名
{
  	//派生类新增成员声明；
};
```

### 2. 公有、私有、保护

> /inherit_demo/inherit_demo/

- 成员
  - 保护成员类外不能访问，派生类可以访问

以下是成员访问控制修饰符的对比表格：

| 访问修饰符        | 含义                         | 类内部 | 派生类 | 外部对象 |
| ----------------- | ---------------------------- | ------ | ------ | -------- |
| 私有（private）   | 只能在类内部访问             | ✔      | ✘      | ✘        |
| 保护（protected） | 可以在类内部和派生类中被访问 | ✔      | ✔      | ✘        |
| 公有（public）    | 可以被任何地方的代码访问     | ✔      | ✔      | ✔        |

这个表格总结了成员访问控制修饰符的区别。对于私有成员，只能在类内部访问；对于公有成员，任何地方的代码和对象都能够访问；对于保护成员，只能在类内部和派生类中访问。

------



- 继承

以下是常见的继承方式对比表格：

| 继承方式 | 派生类访问基类的public成员 | 派生类访问基类的protected成员 | 派生类访问基类的private成员 | 基类成员在派生类对象中继承的方式     |
| :------: | -------------------------- | ----------------------------- | --------------------------- | ------------------------------------ |
| 公有继承 | 是(public=>public)         | 是(protected=>protected)      | 否                          | 作为公有或保护成员存储在派生类对象中 |
| 保护继承 | 是(public=>protected)      | 是(protected=>protected)      | 否                          | 作为保护成员存储在派生类对象中       |
| 私有继承 | 是(public=>private)        | 是(protected=>private)        | 否                          | 作为私有成员存储在派生类对象中       |

------

- 默认继承方式
  - 结构体 struct D1:Base{};  // 公有继承
  - 类 class D2:Base{};           // 私有继承



### 3. 接口继承与实现继承

- 将类的公有成员函数称为**接口**
- 接口继承：（公有继承）  基类的公有成员函数在派生类中仍然是公有的
  - 基类接口称为派生类的接口	
- 实现继承：（私有和保护继承）
  - 重用基类的实现，但是不在支持基类的公有接口



### 4. 继承与重定义

> inherit_demo/inherit_redef

- 对基类数据成员的重定义
  -  
- 对基类成员函数的重定义
  - overwrite
    - 与基类完全相同：函数名和参数
    - 函数名相同，参数不同
  - override
    - 虚函数
- 重载 overload
  - 重载发生在作用域相同的情况下，重定义发生在派生类中	

### 5. 继承与组合

- 无论是继承还是组合
  - 本质：将子对象放在新的类型中
  - 使用构造函数的初始化列表去构造这些子对象
- 推荐使用组合
  - 在新类中用到某个类的一些方法，而不希望有存在类的接口。
  - 新类用户不会看到老类的接口，而是使用老类的接口新定义的一些接口
- 推荐使用继承（子类型化）
  - 希望新类与已有类有相同的接口，在这个基础上可以增加自己的成员
- 里氏代换原则
  - 检验继承的质量

### 6. 不能自动继承的成员函数

> inherit_demo/inherit_constructor

- 构造函数
  - 基类的构造函数不被继承，派生类需声明自己的构造函数
  - 仅需对新增的成员进行初始化
  - 来自基类的的成员通过调用基类构造函数初始化
    - 如果有默认构造函数，会自动调用基类的默认构造函数
    - 如需调用，只能在派生类构造函数初始化列表中完成
  - 派生类构造函数需要给基类构造函数传递参数
  - 构造次序
    - 基类对象成员构造
    - 基类构造
    - 对象成员构造
    - 派生类自身构造
  - 对象成员没有默认构造函数
- 析构函数
- =运算符

### 7. 友元关系与继承

- 友元不能被继承
  - A 是B的友元， C继承了B ，A不是C的友元
  - A 是B的友元， C继承了A ，C不是B的友元
- 友元关系是单向的
  - A是B的友元，可以访问B的任意属性成员，B 不是A的友元
- 友元关系是不可传递的
  - A是B的友元，B是C的友元，A不是C的友元

### 8. 静态成员与继承

- 静态成员被所有类共享，无所谓继承
- 内存只有一份拷贝
- 访问
  - 派生类访问
  - 派生类对象访问
  - 基类访问（推荐）
  - 基类对象访问



### 9. 派生类与基类的转换

> inherit_demo/derived_cast_base

- 派生类以 公有方式public 继承的时候，编译器能够自动执行的转换（向上转型 upcasting 安全转化）

  - 派生类对象指针 =》 基类对象指针
  - 派生类对象引用 =〉基类对象引用
  - 派生类对象 =》基类对象 （特有成员消失）

- Private,protected 继承

  - 不会自动转化

  - 可进行强制转化

    - （type）data;
    - reinterpret_cast<type> data;

    - 不能用 static_cast

  - 转换

    - 派生类对象指针 =》 基类对象指针
    - 派生类对象引用 =〉基类对象引用



### 10. 多重继承

- 一个派生类有多个基类
  - class Derived:继承方式 Base1, 继承方式 Base2 ...{...};
    - 可能会有大量二义性，同名变量或函数
- 解决歧义方法
  - 基类名:: 数据成员名或成员函数
  - 明确指明访问哪个基类成员



### 11. 虚继承与虚基类

- 虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的
- 在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化列表中给出对虚基类的构造函数的调用。如果未列出，则表示调用改虚基类的默认构造函数。
- 在建立对象时，只有最派生类的构造函数调用虚基类的构造函数，改派生类的其他基类对虚基类构造函数的调用被忽略。
