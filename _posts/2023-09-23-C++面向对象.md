---
title: C++ 面向对象
date: 2023-09-21 15:30:00 +0800
categories: [学习笔记, C++]
# toc: false
tags: [c++, 面向对象]     # TAG names should always be lowercase
---

# C++ 面向对象

## 第五课 面向对象介绍

### 1. 结构化程序设计

- 程序

  - 程序是按照一定的逻辑来处理数据

  - pascal之父   结构化程序设计先驱   迪杰斯特拉
    - 程序  = 算法 + 数据结构

  - 程序是完成一定功能的一系列有序指令的集合
    - 指令 = 操作码 + 操作数

- 语言

  - 机器语言
    - 机器能读懂的语言，二进制指令集合

  - 汇编语言
    - 将机器指令映射为一些可以被人读懂的助记符

  - 高级语言
    - 屏蔽了机器的细节，提高了语言的抽象层次

- 机器语言和汇编语言是在机器的角度考虑问题，代码和数据的界限模糊

- 结构化程序设计

  - 自顶向下

  - 程序  = 算法 + 数据结构

  - 将程序分为不同的模块，使得整个程序更加具有条理性

  - 多数数据仍属于整个程序，具有许多全局变量，在某些地方更改可能会影响其他地方

  - 考虑问题以算法为中心，不以数据为中心

  - 要求软件负责人了解整个任务分解

  - 缺陷

    - 程序难以管理
    - 数据修改存在问题
    - 程序可重用性差

    - 用户要求难以在系统分析阶段准确定义，致使系统在交付阶段存在许多问题
    - 用系统开发每个阶段的成果来进行控制，不能适应事物变化的要求，
    - 不适合大型软件的开发

### 2. 面向对象程序设计

- 将系统看作是通过交互来完成特定功能的对象的集合。每个对象用自己的方法来管理数据	
  - 程序 = 对象 +...+ 对象  + 	数据交互
  - 对象 = 算法 + 数据结构 （封装思想）
  - 以对象为中心
  - 同类对象可以抽象出共性（类）
    - 类中的数据通常通过本类中的方法进行处理
    - 类中的方法成为与外部的接口
    - 对象之间通过消息进行通讯
- 特征
  - 抽象
  - 封装
  - 继承
  - 多态
- 数据抽象
  -  结构化程序设计是对过程的抽象，以算法（过程）为中心	
     - 将共同的操作抽取出来，看成一个实体
  -  面向对象是数据抽象，是更高级的抽象
     - 将描述客体的属性和行为进行绑定，实现统一的抽象

### 3. 从计算机的观点看对象

- 对象是计算机内存中的一块区域，通过内存分块，每个对象在功能上相对保持独立。
- 内存不仅存储数据，还存储代码。保证对象是受保护的，只有对象中的代码能访问存储于对象中的数据。

- 对象之间只能通过函数调用来发送消息实现相互通信。
- 对象的一个函数被调用时，对象执行内部代码来响应该调用，从而呈现一定的行为

### 4. 抽象

- 抽象是人们认识事物的一种方法
- 抓住事物本质，而不是内部具体细节或具体实现
- 抽象：从具体到一般的一个过程
- 对象 => 类（归类）  

### 5. 封装

- 按照信息屏蔽的原则，把对象的属性和操作结合在一起，构成独立的对象
- 通过限制对属性和操作的访问权限，可以将属性隐藏在对象内部，对外提供一定的接口，在对象之外只能通过一定的接口对对象进行操作
- 封装增加了对象的独立性，从而保证了对象的可靠性
- 外部对象不能直接操作对象的属性，只能使用对象提供的服务

### 6. 继承

- 继承表达了对象的一般与特殊的关系。特殊类的对象具有一般类的全部属性和服务。
- （大类）=> （小类）新类中只需描述自己所特有的属性和操作
- 继承简化了对问题的描述。提高了程序的复用性，提高了程序设计、修改、扩充的效率。

### 7. 多态

- 多态性：同一个消息被不同的对象接收时，产生不同的结果。即实现同一接口，不同方法。
- 一般类中定义的属性和方法，在特殊类中不改变其名字，但通过各自不同的实现后，可以具有不同的数据类型或有不同的行为。

> 继承和多态性的结合，可以生成很多相似但又独一无二的对象。继承性使得这些对象可以共享许多相似特性，而多态又使得同一操作对不同对象产生不同的表现形式。提高了程序设计灵活性，减轻了分别设计的负担。

### 8.  面向对象程序设计思想

- 面向对象是一种程序设计方法，也是一种认识世界的方法
- 客观世界 =》 实体  =〉 对象组成的
- 对象
  - 内部状态（静态）
  - 运动规律（动态）
- 对象之间的联系构成了不同的系统

### 9. 面向对象编程

- 面向对象编程方法的特性
  - 重点在数据而不是函数
  - 不是完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为
  - 对象之间通过相互协作来完成功能
  - 函数与相关数据紧密结合
  - 数据可以被隐藏
  - 很容易扩充新的数据和函数
  - 开闭原则：对增加开放，对修改、删除关闭
- 优点
  - 易维护：可读性高，即使改变需求，由于继承的存在，维护也只是在局部模块
  - 质量高：可重用已被测试的类
  - 效率高
  - 易扩展
- 缺点
  - 运行效率会下降10%左右

## 第六课 类与对象

> 2023/class_demo.   2023/class_clock_demo.cpp.  2023/class_clock_demo_2.cpp

### 1. 类定义

- 类声明

```c++
class 类名
{
  public:
  	// 公有成员（外部接口）
      int a;
  protected:
    // 保护成员
  private:
  	// 私有成员
};
```

- 公有、私有、保护成员
  - public
    - 类与外部的接口，外部可访问公有类型数据和函数
  - private 
    - 只允许本类中的函数
  - protected
    - 继承和派生类可访问，其他类似private

### 2. 抽象与封装

- 数据抽象
  - 接口和实现分离
  - 类设计者：如何实现
  - 使用类程序员：不需要了解类实现细节，只需知道类能做什么
- 封装
  - 将低层次的元素组合	=》 新的、高层次实体
  - 函数封装
  - 类封装

### 3. 内联函数

> 2023/class_inline.cpp

- 编译的时候直接将代码嵌入到调用的地方，从而减少了函数调用的开销。
- 体积增大，空间换时间
- 表现形式
  - 直接在类体中给出成员函数代码，不在外部定义，内联成员函数
  - 声明时可以不用给出inline 关键字， 实现时给出 inline 关键字
- 常常较为短小，如果有switch、for，编译器可能不会将其按内联函数解析

### 4. 成员函数重载

- class_overload.cpp

- 类与结构体
  - 区别：在未指定访问权限时，class 默认是private， struct 默认是 public
  - class_struct.cpp

> 2023/class_overload.cpp\class_struct.cpp

### 5. 隐含的 this 指针

- 在定义一个对象时会分配内存，同一个类中定义了多个对象，
- 成员函数有一个隐含的附加形参，指向该对象的指针，叫做this指针
- 在访问成员函数时成员函数共享，通过隐含的 this  指针确定对象
- **this 指针保证了不同的对象能够拥有不同的数据成员，但处理这些成员的代码可以被所有对象共享**。
- this 指针指向了构造的对象, 使得成员函数能对相应的对象进行操作

```c++
void Init(int m_x, int m_y, int m_z);
// =>
t1.Init(1, 2, 3);
t2.Init(10, 20, 30;

// =>
t1.Init(&t1, 1, 2, 3);
t2.Init(&t2, 10, 20, 30);      
```

### 6. 类作用域

> 2023/class_domain.cpp

- 每个类都定义了自己的作用域称为类作用域
- 类作用域中的标识符只在类内可见
- 作用域
  - 块作用域 ：{} 内
  - 文件作用域
  - 函数原型作用域
  - 函数作用域
  - 类作用域

### 7. 前向声明

> 2023/class_cross_ref

- c++ 中的类必须先定义才能实例化
- 当两个类相互引用出现环形引用时，无法先定义使用。这时候需要用到前向声明。
  - 类A：初始化类B
  - 类B：初始化类A

### 8. 嵌套类

> 2023/class_inter_outer.cpp

- 外围类需要使用嵌套类对象作为底层实现，并且该嵌套类只用于外围类的实现，且同时可以对用户隐藏该底层类实现。
- 作用域：嵌套类被隐藏在外围类之中
- 嵌套类的成员函数可以在类体外定义，需加作用域
- 嵌套类中的成员函数对外围类中的私有成员没有权限访问，反之亦然

### 9. 局部类

> 2023/class_local.cpp

- 类也可以定义在函数体内，这种类称为局部类，局部类只在定义他的局部域可见
- 局部域的成员函数必须定义在类体中
- 局部类不能有静态成员。

> 2023/class_local.cpp

### 10. 空类

- 默认参数成员函数

  - 默认构造函数：Test();

  - 默认析构函数:   ~Test();

  - 默认拷贝构造函数:  Test(const Test&);

  - 默认等号运算符:    Test &operator=(const Test&);

  - 默认取址运算符:     Test* operator&();

  - 默认常量取地址：  const Test* operator&() const;

- 空类大小为一个字节

## 第七课 构造函数和析构函数

### 1. 构造函数

> 2023/constructor_demo.cpp.     2023/constructor_global.cpp.  2023/constructor_arr.cpp. 

- 构造函数是特有的成员函数
- 创建对象时系统会自动调用构造函数
- 保证每个数据成员正确初始化
- 定义规则
  - 函数名称和类名完全相同
  - 不能定义构造函数的类型（返回类型）
  - 通常应该声明为公有成员函数，否则不能像其他成员函数那样显示调用
    - 私有声明有特殊用途
  - 一个类可以有多个构造函数（函数重载）
- 全局对象的构造先于 main 函数

- 默认构造函数

  - 不带参数的构造函数称为默认构造函数

  - 如何类不提供任何构造函数，系统会提供一个不带参数的构造函数，如果定义了，系统将不自动提供默认构造函数

- new

  - 不仅申请了内存，还调用构造函数

### 2. 析构函数

- 析构函数不能被重载，没有参数
- 函数名和类名相似，多一个`~`：取反
- 没有返回类型，没有参数
- 如果没有定义析构函数，编译器会默认生成一个析构函数
- 默认析构函数是一个空函数
- delete
  - 不仅释放了内存，还调用了析构函数
- 析构函数的显示调用
  - 不推荐，一般很少用
  - 如果析构函数中有对数据处理，会进行多次处理

### 3. 转换构造函数

> 2023/tran_constructor.cpp

- 构造函数功能
  - 初始化
  - 类型转化（转换构造函数）
- 赋值和初始化的区别
  - 将整数赋值给类对象
    - 先初始化一个对象，再进行赋值，
    - 赋值过程重载了 “=”
- explicit
  - 只提供给类的构造函数使用的关键字、
  - 编译器不会把声明为 explicit 的构造函数用于隐式转换，它只能在程序代码中显示创建对象
  - 只能显示构造
  - Test t=30；不再等价于 Test t(30);

### 4. 构造函数初始化列表

> 2023/constuctor_init_list.cpp

- 推荐在构造函数初始化列表中进行初始化
- 构造函数的执行分为两个阶段
  - 初始化段。
  - 普通计算段 ：构造函数体内

### 5. 对象成员的初始化

> 2023/object_member_init.cpp

- 对象成员没有默认构造函数，要用初始化列表对对象成员进行初始化

### 6. const成员、引用成员初始化

> 2023/const_ref_member_init.cpp.  2023/const_object_member.cpp.

- 常量成员必须在初始化列表中进行初始化

- 引用成员的初始化也必须在初始化列表中进行

- 对象成员如果该类没有默认构造函数，初始化必须在初始化列表中进行

- 常量如果要定义一个对于每个对象都是相同的常量，可以用枚举方法

  - c++ 11 允许直接进行常量的定义

  - > 2023/const_object_member.cpp



### 7. 拷贝构造函数

> 2023/copy_constructor.cpp.   2023/copy_constructor_func.cpp.

- 功能：使用一个存在的对象来初始化一个新的同一类型的对象

- 声明：
  - 只有一个参数
  - 参数为某类的引用
- 如果类中没有说明拷贝构造函数，则系统自动生成一个缺省拷贝构造函数，作为该类的公有成员。
- 拷贝构造函数调用
  - 当函数的**形参是类的对象**，调用函数时，需要建立一个局部对象，把形参拷贝到新的对象中，需要调用拷贝构造函数。
  - 当函数的**返回值是类的对象**，函数执行完成返回调用者时需要调用拷贝构造函数。局部变量在函数结束时被释放，不能直接返回局部变量

### 8. 深拷贝和浅拷贝

> 2023/deep_copy.cpp.  2023/deep_copy.cpp.

- 如果类内部要实现动态内存分配，一般要使用深拷贝，不共享内存 。
- 等号运算符对类的赋值操作时，系统提供的是浅拷贝，如果需要参拷贝需要进行运算符重载。
- 禁止拷贝
  - 独一无二的对象，禁止拷贝
  - 将拷贝构造放到私有成员函数，且不提供函数实现





## 第八课 对象的使用

> object_demo

### 1. static 成员

> object_demo/static_demo/static_const.cpp.  object_demo/static_demo/static_member.cpp.

- 对于特定的全局对象而言，有时候需要访问一个全局变量：统计某种对象创建的数量

  - 所有同类对象共享的变量
  - 如果用全局变量，破坏了数据的封装，
    - 不是该类也可以共享这个变量
    - 会被滥用

- 可以利用静态成员变量来定义一个所有同类共享的的数据

  - 类内进行引用性声明
  - 类外进行定义性声明
    - 定义
    - 初始化
  - 文件作用域

  - 初始化在类外进行定义性声明
  - 静态成员默认初始化为0；

- 非静态成员存在于对象中

- static 成员独立于对象存在，是与类关联的，不是与对象关联的，被所有类对象共享

- static 成员优点

  - 是在类作用域，避免与其他类成员或其他变量命名冲突
  - 可以实施封装
    - static 成员可以是私有的，全局对象不可以
      - 需提供公有接口访问
  - 阅读时容易看清 static成员的关联类，了解程序员意图，程序关联性够强

- static const 成员

  - 可以在类体内初始化(仅限 int、char 类型)

> 统计某个类创建对象的个数

### 2. 静态成员函数

> object_demo/static_member_func

- **没有 this 指针**
- 非静态成员函数可以访问静态成员
- 静态成员函数不可以访问非静态成员

### 3. 类/对象大小的计算

- 遵循结构体对齐原则
- 类大小与数据成员有关，和成员函数无关
- 与静态数据成员无关
- 虚函数对类大小的影响
  - 有一个虚函数会增加4个字节空间：指向虚表的指针
- 虚继承对类的大小的影响

### 4. 对象作用域与生存期

> object_demo/object_life

- 栈对象
  - 隐含调用构造函数
- 堆对象
  - 隐含调用构造函数
- 全局对象、静态全局对象
  - 全局对象的构造先于main函数
  - 已初始化的全局变量或静态全局对象存储于 .data 段中
  - 未初始化的全局变量或静态全局对象存储于 .bss 段中
    - 可执行文件中不占空间
    - 默认值为0
- 静态局部对象
  - 已初始化的静态局部对象存储于 .data 段中
  - 未初始化的静态局部对象存储于 .bss 段中
  - 静态局部对象在运行期间初始化
  - 普通静态局部变量在编译期间初始化

> 作用域和生存期不总是等同的

### 5. static 用法总结

- c
  - 用于函数内部修饰变量，函数内的静态变量。
    - 这种变量的生存期长于函数
    - 这个函数变成有状态的，再次进入不再分配空间（不可重入函数，也不是线程安全的）
  - 用于函数体外（文件级别），修饰变量或函数
    - 该变量或函数只在本文件中可见，其他文件看不到也无法访问。（internal linkage）
      - extern：external linkage
      - 全局变量应该在 .c 文件中定义
- c++
  - 兼容 c
  - 用于修饰类的数据成员（静态成员）
    - 生存期大于类对象
    - 静态成员每个类一份（内存）
    - 普通成员每个对象一份（内存）、
  - 用于修饰类的成员函数 （静态成员函数）
    - 只能访问静态成员和其他的静态成员函数	
    - 不能访问非静态成员和非静态成员函数
    - 没有 this 指针

### 6. static 与单例模式

> object_demo/static_singleton.  object_demo/static_singleton_2

- 设计模式

- 单例模式

  - 保证一个类只有一个实例，并提供一个全局访问点

  - 禁止拷贝

  - 释放实例

    - 利用对象的确定性析构

      - 定义类成员
      - 在类成员的析构函数中进行释放
      - 在类成员中定义一个静态成员变量，在静态成员变量释放时自动的析构实例对象

    - 利用静态局部变量

      - 静态局部变量在运行时初始化，由于已经创建单例对象，此时就不用初始化静态局部变量了

      - 不是线程安全的

### 7. const 成员函数

> object_demo/const_member_func

- const 成员函数不会修改对象的状态
- 只能访问数据成员的值，不能够修改数据成员

### 8. const 对象

> object_demo/const_member_func

- 如果把一个对象定义为 const，就是告诉编译器不要修改他
- const 对象定义
  - const 类名 对象名(参数表)；
- const 对象不能调用 非const成员函数

### 9.mutable 关键字

- 用 mutable（易变的） 修饰的数据成员即使在 const 对象或在 const成员函数中都可以被修改

### 10. const 总结

- 定义常量  
  - const int n = 100；
  - const Test t(10);
  - 定义后必须初始化

- const 引用
  - const 引用可以引用到一个 const 常量
  - 普通引用不能引用到一个 const 常量
- const 可以修饰指针
  - const *p：
    - 指针常量
    - 内容不可变
  - *const p
    - 常量指针
    - 指针不可变
- 在类中
  - const 成员初始化只能在初始化列表中进行
  - const 修饰成员函数

### 11. 数据抽象和封装

- 实现一个栈
  - 数据
    - 链表形式
    - 头节点
    - 栈长
  - 方法
    - 初始化
    - push
    - pop
    - 栈空
    - 清空
  - c++ 和 c 区别
    - c++使用类在构造和析构中进行初始化和清空。
    - c++不用传递地址，直接利用对象的成员函数进行调用，隐含this指针
    - c++ 可以有效避免名字冲突，都是类内的成员函数。用c的话可能其他也有相同名字的方法
      - 类作用域
      - 也可使用作用域来避免 namespace
    - c实现的方法没有被封装，可以外部直接访问。c++实现封装，可以保证数据对象的安全，不被外界破坏

## 第九课 友元

> friend/friend_class/

### 1. 友元介绍

- 友元是一种允许非类的成员函数访问类的非公有成员的一种机制

- 可以把一个函数指定为类的友元，也可以将整个类指定为类的友元
  - 友元函数
  - 友元类

### 2. 友元函数

- 在类的作用域外进行定义，在类体进行说明
- 定义
  - friend 类型 友元函数名（参数表）
- 友元函数能够提高程序运行效率



### 3. 友元函数注意事项

- 友元函数作用域不在类体
  - 如果友元函数是其他类的成员函数，作用域在其他类中
- 友元函数不是类的成员函数
- 友元函数可以访问类中所有成员
- 友元函数破坏了面向对象的封装性，必要的时候使用，或者利用其他手段保持封装性



### 4. 友元类

- 类B 需要频繁的使用 类A 中的私有和保护成员，可以将B作为A的友元类
- 友元类：一个类可以作为另一个类的友元
- 友元类的所有成员函数都是另一个类的友元函数
- 友元类声明：
  - friend class 类名；

### 5. 友元类注意事项

- 友元关系是单向的
- 友元关系不能被传递
  - A是B的友元，B是C的友元   $\ne$   A是C的友元。
- 友元关系不能被继承



## 第十课 运算符重载

### 1. 运算符重载

- 允许把标准运算符（+、-、*、/、<、> 等）应用于自定义数据类型的对象
  - 自定义类型的数据也可以使用这些符号
- 直观自然、提高程序的可读性
- 体现了 c++ 的课扩充性
- 运算符重载本质是函数重载
- 不要滥用重载，
  - 使得代码更容易写、更容易读是才有必要使用
- 格式
  - 成员函数重载
  - 非成员函数重载
    - friend 函数类型 类名::operator 运算符(参数表){函数体；}
    - 友元函数重载比成员函数重载多一个参数

### 2. 运算符重载规则

- 不允许发明新的运算符
- 不能更改运算符操作的对象数
- 运算符重载后，其优先级和结合性不会改变
- 不能重载的运算符
  - 作用域解析运算符：`::`
  - 条件运算符：`?:`
  - 直接成员访问运算符：`.`
  - 类成员指针引用的的运算符:`.*`
  - Sizeof运算符：`sizeof`

- 一般情况下，单目运算符最好重载为类的成员函数；双目运算符最好重载为类的友元函数。

- 以下运算符不能重载为类的友元函数

  - =
  - ()
  - []
  - ->

  - 类型转换运算符

- 流运算符只能以友元的方式重载

### 3. ++ 运算符重载

> operator_overload/operator_addadd

- 前置 ++ 运算符重载
  - 成员函数方式
    - 函数类型& operator++()
  - 友元函数方式
    - friend 函数类型& operator++(数据类型 &)
- 后置 ++ 运算符重载
  - 成员函数方式
    - 函数类型& operator++(int)
    - 新增 int 参数，无特殊意义
  - 友元函数方式
    - friend 函数类型& operator++(数据类型 &, int)



### 4. = 赋值运算符重载

> operator_overload/operator_assignment



### 5. ! 运算符重载

- Demo：实现功能
  - 字符串为空 
    - return false
  - 不为空
    - return true 

### 6. String 重写

- []
- +
- +=
- <<
- \>>

### 7. 流运算符重载

> operator_overload/String/

- c++的I/O 流库重要特性能够支持新的数据类型的输入和输出
- 插入符：<< 
- 提取符：>> 
- 重载只能用友元函数重载



### 8. 类型转化运算符重载

> operator_overload/operator_convert/

- 必须是成员函数，不能是友元函数
- 没有参数
- 不能指定返回类型
- 函数原型
  - operator 类型名();



### 9. 指针运算符 ->

> operator_overload/operator_point/



### 10. new/delete

> operator_overload/operator_new/

- new
  - new operator
  - operator new
  - placement new
- delete

- 两者一一对应
