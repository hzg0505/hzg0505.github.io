# Build Your Own Database

> 主要涉及网络编程和数据结构



## 简介

### 1. about

- 数据结构 持久化
  - B-Tree
  - KV store
  - 关系数据库

- 重点
  - 持久化
    - 不丢失和损坏数据，从崩溃中恢复
  - 索引
    - 高效查询和操作
  - 并发性
    - 大量处理



### 2. 持久化

- 不直接将数据转储到文件中，写入中途崩溃或断电了文件状态
- 不使用数据库情况下持久化 （数据集较小时）
  - 将整个更新的数据集写入新文件
  - 调用 fsync 新文件
  - 通过将新文件重命名为旧文件来覆盖旧文件，这通过文件系统=》原子操作

### 3. 索引

- 不通类型的数据库查询
  - 分析型（OLAP）
    - 涉及大量数据
    - 聚合、分组、连接操作
  - 事务型（OLTP）
    - 少量索引数据
    - 索引点查询
    - 索引范围查询
  - 数据结构
    - B 树
    - LSM 树

### 4. 并发

- 读者之间的并发
- 读取器和写入器之间的并发
- 原子执行（读取-修改-写入）
- 事务



## 文件 vs 数据库 （持久化）

### 1. 数据存入文件

- 文件需要同时被读取，在读取是不能写
- 写数据应该是原子操作，在写时读获取的数据是不完整的
- 数据什么时候写入磁盘，数据可能存储在页表中，当操作系统崩溃重启时，文件状态是什么？



### 2. atomic renaming

- 方法

  - 新建一个临时文件

  - 数据写入临时文件

  - 临时文件 rename 为 目标文件

  - rename 操作是原子的

- 解决的问题
  - 系统在 rename 前崩溃时，原始文件没有被污染
  - 读取文件没有问题
- 存在问题
  - 无法控制数据何时持久化到磁盘
    - 元数据（文件大小）可能会在数据之前持久化到磁盘，此时系统崩溃的话，元数据是错误的会损坏文件
  - 元数据
    - 文件描述符，文件状态标志、文件类型、文件大小、文件访问时间、文件修改时间、文件创建时间、文件权限

### 3. fsync

- 我们需要在临时文件重命名之前将数据刷新到磁盘，系统调用 ”fsync“

- 但是我们并没能对元数据进行持久化

- 2 中没对数据持久化，3 中可能出现在元数据持久化之前系统崩溃，都会损坏文件。



### 数据库更好进行持久化（相对于文件）

> append-only log 此场景下不修改存在的数据，没有rename操作，可以很好的持久化。





## 索引

### 1. Key-Value Store 和 关系数据库

- 磁盘操作	
  - 扫描（no index）
  - 点查询 （key => value）
  - 范围查询（排序）

- Hashtables 
  - sorting and ordering
  - 调整大小耗时 O(n)
- B 树 O(log(n))
  - 二叉树  =》 多叉树
    - 空间利用率高
    - 减少磁盘IO（短） =〉页表大小
    - faster in memory
- LSM-Trees （Log-structured merge-tree）
  - 高效索引
  - 持久化存储
  - 结局写入性能较差的问题，会牺牲部分读性能



## B-Tree

- 不可变数据（不就地更新数据  no inplace ）
  - 避免数据损坏
    - 不会修改现有数据，只是添加新数据，即使更新中断，旧版本的数据也保持不变
  - 轻松并发
    - 读者可以与写者同时操作，读者可以在不受影响的旧版本上工作

- 编写一个不可变的 B+ 树