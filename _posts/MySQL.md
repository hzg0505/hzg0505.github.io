# MySQL

### 1. 数据库

数据库（Database）是用于**存储和组织数据的集合**，可通过计算机系统进行**访问、管理和操作**。数据库的主要目的是提供一个结构化的数据存储和检索机制，以便有效地**存储、检索、更新和删除**数据。数据库通常包含表格、字段、索引和关系等概念。

#### 1.1 概念

数据库的主要概念包括：

- **数据**: 数据库是用于存储数据的地方。数据可以是文本、数字、图像、音频、视频等各种形式的信息。
- **表格（Table）**: 数据库中的数据通常以表格的形式组织，每个表格包含一组相关的数据。每个表格由一组列（字段）和行（记录）组成。
- **字段（Column）**: 表格的列，代表特定类型的数据。字段定义了数据的类型和约束条件。
- **记录（Row）**: 表格的行，包含一组字段的具体数据。
- **主键（Primary Key）**: 一种特殊的字段，用于唯一标识每个记录。主键确保每个记录在表格中都是唯一的。
- **外键（Foreign Key）**: 用于建立表格之间的关系。外键是一个表格的主键，可以用于与另一个表格中的记录建立关联。
- **索引（Index）**: 用于提高数据检索性能的数据结构。索引允许快速查找表格中的记录。
- **关系型数据库（RDBMS）**: 使用表格和SQL查询语言来组织和操作数据的数据库类型。例如，MySQL、Oracle、SQL Server。
- **非关系型数据库（NoSQL）**: 不使用表格结构的数据库类型，而使用文档、键-值、列族等其他数据模型来存储数据。例如，MongoDB、Cassandra、Redis。

#### 1.2 分类

数据库可以根据不同的标准进行分类，其中一些常见的分类包括：

- **按数据模型分类**:
  - **关系型数据库（RDBMS）**：使用表格、行和列的结构，具有事务支持和SQL查询语言。
    - **SQL（Structured Query Language）**：操作关系型数据库的编程语言，定义了一套操作关系型数据库的统一**标准**。
    - 主流的关系型数据库
      - Oracle 
      - MySQL
      - Microsoft SQL Server
      - PostgreSQL
      - SQLite
  - **非关系型数据库（NoSQL）**：使用其他数据模型，如文档、键-值、列族等，通常用于大数据和分布式系统。
- **按部署方式分类**:
  - **本地数据库**：部署在单个计算机上的数据库系统，通常用于个人或小型应用。
  - **中央数据库**：位于中央服务器上，可以由多个客户端访问，通常用于企业级应用。
  - **分布式数据库**：数据存储在多个地理位置的服务器上，支持大规模和高可用性的应用。
- **按数据处理方式分类**:
  - **在线事务处理数据库（OLTP）**：用于支持日常事务处理，如订单处理和银行交易。
  - **在线分析处理数据库（OLAP）**：用于支持复杂的数据分析和报告生成，通常用于商业智能应用。
- **按数据模型分类**:
  - **文档数据库**：数据以文档的形式存储，如JSON或XML。
  - **键-值存储**：数据以键-值对的形式存储。
  - **列族数据库**：数据以列族的形式存储，适用于大规模数据分析。

### 2. MySQL

#### 2.1 安装

- brew install mysql

#### 2.2 测试指令

1. 启动MySQL服务器：
   - `mysql.server start` 用于启动MySQL服务器。
2. 使用Homebrew服务启动MySQL：
   - `brew services start mysql` 用于使用Homebrew服务管理启动MySQL。这将在系统启动时自动启动MySQL服务器。
3. 连接到MySQL服务器：
   - `mysql -u root -p` 用于连接到MySQL服务器。它将提示你输入root用户的密码，然后让你进入MySQL客户端。
4. 显示数据库列表：
   - `show databases;` 用于列出MySQL服务器中所有的数据库。
5. 使用特定数据库：
   - 使用 `use mysql;` 来选择或切换到名为 "mysql" 的数据库。这会将后续的操作限制在该数据库中。
6. 显示表格：
   -  `show tables;` 用于列出所选数据库中的所有表格。
7. 查询表格的内容：
   - `select * from tables_priv` 用于查询名为 "tables_priv" 的表格中的所有数据。但要注意，`tables_priv` 是MySQL内部数据库 "mysql" 中的表格，通常包含访问权限信息。

#### 2.3 数据模型

- 数据库管理系统
- 数据库
- 表
- 记录

#### 2.4 数据类型

- 数值类型

### 3. SQL

SQL是一种用于管理和操作关系型数据库的标准化语言，它包括以下几个主要部分：

#### 3.1 DDL 数据定义语言

DDL（Data Definition Language）用于定义数据库结构，包括**表格、列、索引**和其他对象的创建、修改和删除。一些主要的DDL命令包括：

- `CREATE TABLE`：用于创建新的表格。
- `ALTER TABLE`：用于修改现有表格的结构。
- `DROP TABLE`：用于删除表格。
- `CREATE INDEX`：用于创建索引。
- `DROP INDEX`：用于删除索引。



#### 3.2 DML 数据操作语言

DML（Data Manipulation Language）用于对数据库中的**数据进行操作**，包括插入、更新、删除和查询数据。一些主要的DML命令包括：

- `INSERT`：用于将新数据插入到表格中。
- `UPDATE`：用于修改表格中现有的数据。
- `DELETE`：用于从表格中删除数据。
- `SELECT`：用于查询数据库中的数据。

#### 3.3 DQL 数据查询语言

DQL（Data Query Language）是SQL的一个子集，专门用于查询数据。它的主要命令是 `SELECT`，用于从一个或多个表格中检索数据，以满足特定的查询条件。DQL用于从数据库中**检索信息**，而不修改或删除数据。

#### 3.4 DCL 数据控制语言

DCL（Data Control Language）用于管理数据库的**访问权限和安全性**。它包括以下命令：

- `GRANT`：用于授予用户或角色对特定数据库对象的权限。
- `REVOKE`：用于撤销用户或角色对数据库对象的权限。

DCL命令用于管理数据库的访问控制，确保只有授权用户可以访问和修改数据库中的数据。

这些SQL部分一起构成了数据库管理系统（DBMS）的功能，使用户能够定义数据库结构、操作数据和确保数据安全性。不同的DBMS可能会有稍微不同的SQL语法，但SQL的基本原则在不同系统中通常是一致的。



#### 3.5 聚合函数

 `COUNT()`、`AVG()`、`SUM()`、`MAX()` 和 `MIN()` 是 SQL 中常用的聚合函数，它们用于对数据进行汇总和分析。以下是这些聚合函数的说明：

- `COUNT()`: `COUNT()` 用于计算某个列中的行数，或者计算满足特定条件的行数。你可以使用 `COUNT(*)` 来计算表中的总行数，或者使用 `COUNT(column)` 来计算某一列非空值的行数。

- `AVG()`: `AVG()` 用于计算某一列的平均值，通常用于数值型数据列。它将列中所有的数相加，然后除以行数，得到平均值。

- `SUM()`: `SUM()` 用于计算某一列的总和，通常也用于数值型数据列。它将列中所有的数相加，得到总和。

- `MAX()`: `MAX()` 用于找到某一列中的最大值。它返回该列中的最大值。

- `MIN()`: `MIN()` 用于找到某一列中的最小值。它返回该列中的最小值。

这些聚合函数通常与 `GROUP BY` 子句一起使用，以对数据进行分组并对每个组应用聚合函数。例如，你可以使用 `GROUP BY` 来对不同产品类别的销售数据进行分组，然后使用 `SUM()` 计算每个类别的总销售额。

> 所有 NULL 不参与聚合计算

#### 3.6 连接方式

- 内连接：内连接通过`INNER JOIN`来实现，它将返回两张表中满足连接条件的数据，不满足条件的数据不会查询出来。

- 外连接：外连接通过`OUTER JOIN`来实现，它会返回两张表中满足连接条件的数据，同时返回不满足连接条件的数据。外连接有两种形式：左外连接（`LEFT OUTER JOIN`）、右外连接（`RIGHT OUTER JOIN`）。

- 左外连接：可以简称为左连接（`LEFT JOIN`），它会返回左表中的所有记录和右表中满足连接条件的记录。
- 右外连接：可以简称为右连接（`RIGHT JOIN`），它会返回右表中的所有记录和左表中满足连接条件的记录。

除此之外，还有一种常见的连接方式：等值连接。这种连接是通过 `WHERE` 子句中的条件，将两张表连接在一起，它的实际效果等同于内连接。出于语义清晰的考虑，一般更建议使用内连接，而不是等值连接。

以上是从语法上来说明表与表之间关联的实现方式，而从表的关系上来说，比较常见的关联关系有：一对多关联、多对多关联、自关联。

- 一对多关联：这种关联形式最为常见，一般是两张表具有主从关系，并且以主表的主键关联从表的外键来实现这种关联关系。另外，以从表的角度来看，它们是具有多对一关系的，所以不再赘述多对一关联了。
- 多对多关联：这种关联关系比较复杂，如果两张表具有多对多的关系，那么它们之间需要有一张中间表来作为衔接，以实现这种关联关系。这个中间表要设计两列，分别存储那两张表的主键。因此，这两张表中的任何一方，都与中间表形成了一对多关系，从而在这个中间表上建立起了多对多关系。
- 自关联：自关联就是一张表自己与自己相关联，为了避免表名的冲突，需要在关联时通过别名将它们当做两张表来看待。一般在表中数据具有层级（树状）时，可以采用自关联一次性查询出多层级的数据。

#### 3.7 其他

- `CASE...WHEN...THEN` 是 SQL 中用于条件判断和生成计算字段的常用语法结构。它允许你根据一个或多个条件生成不同的结果，类似于编程中的条件语句。`CASE` 表达式通常有两形式：简单 `CASE` 表达式和搜索 `CASE` 表达式。
  - **简单 CASE 表达式：** 这种形式的 `CASE` 表达式用于比较一个表达式（通常是列）与一组常量值，并在匹配时返回相应的结果。

```sql
SELECT
  product_name,
  CASE category_id
    WHEN 1 THEN 'Electronics'
    WHEN 2 THEN 'Clothing'
    WHEN 3 THEN 'Books'
    ELSE 'Other'
  END AS category
FROM products;
```

在上面的示例中，根据 `category_id` 的值，`CASE` 表达式将返回不同的 `category` 值。如果没有匹配的条件，将返回 `Other`。

- **搜索 CASE 表达式：** 这种形式的 `CASE` 表达式用于根据多个条件生成结果，类似于使用逻辑运算符 `OR` 和 `AND` 来组合多个条件。

```sql
SELECT
  order_id,
  CASE
    WHEN total_amount > 1000 THEN 'High'
    WHEN total_amount > 500 THEN 'Medium'
    ELSE 'Low'
  END AS order_priority
FROM orders;
```

在上面的示例中，`CASE` 表达式使用多个 `WHEN` 子句来根据不同的条件生成 `order_priority` 值。只有第一个匹配的条件会返回相应的结果，所以顺序很重要。

`CASE...WHEN...THEN` 结构在 SQL 查询中非常有用，可以用于生成复杂的计算字段，条件筛选和映射值。根据你的具体需求，你可以使用这种结构来进行条件判断和结果生成。

#### 3.8 通用语法

- 可单行多行书写，以分号结尾
- 可以使用空格/缩进  => 代码可读性
- SQL 不区分大小写，关键字建议大写
- 注释
  - 单行： -- 或 #
  - 多行：/* 注释内容 */

### 4. 数据库导出

- ```shell
  mysqldump -u root -p game > game.sql
  ```

- ```shell
  mysql -u root -p game < game.sql
  ```





### 5. 事务

#### 5.1 简介

- 事务：在数据库管理系统（DBMS）中，事务（Transaction）是一组数据库操作（或 SQL 语句）的逻辑单元，这些操作被视为单一的工作单元。事务的目的是**确保数据库的一致性和完整性**，以及维护数据的**可靠性**。事务可以包含一个或多个数据库操作，如插入、更新、删除等。
- 事物特性（ACID）
  - **原子性（Atomicity）：** 事务被视为不可分割的单元，要么完全执行，要么完全回滚。如果在事务执行过程中发生错误，那么事务将被回滚，以保持数据库状态的一致性。
  - **一致性（Consistency）：** 事务在执行前后，数据库应该保持一致的状态。这意味着事务执行后，数据库应该仍然遵循定义的约束和完整性规则。
  - **隔离性（Isolation）：** 多个事务可以并行执行，但它们的操作应该相互隔离，不应该相互干扰。这可以通过锁定和并发控制来实现，以防止数据竞争和冲突。
  - **持久性（Durability）：** 一旦事务成功提交，其结果应该在数据库中永久保存，即使系统发生故障也应该如此。这通常需要数据的**持久化存储**，如写入磁盘。

#### 5.2 事务操作

1. **开启事务**（Start Transaction）：使用 `START TRANSACTION` 或 `BEGIN` 语句来开始一个新事务。例如：

   ```sql
   START TRANSACTION;
   -- 或者
   BEGIN;
   ```

   

2. **执行 SQL 操作**：在事务中执行你想要的 SQL 操作，如插入、更新或删除数据。例如：

   ```sql
   INSERT INTO table_name (column1, column2) VALUES (value1, value2);
   UPDATE table_name SET column1 = new_value WHERE condition;
   DELETE FROM table_name WHERE condition;
   -- 其他 SQL 操作
   ```

   

3. **判断事务结果**：在执行每个 SQL 操作后，你可以检查操作是否成功。如果出现任何错误或问题，你可以选择回滚事务。

   ```sql
   -- 例如，检查是否有错误
   IF condition THEN
       ROLLBACK;
   END IF;
   ```

4. **提交事务**（Commit Transaction）：如果所有操作都成功，你可以使用 `COMMIT` 语句来提交事务，将所有更改永久保存到数据库。

   ```sql
   COMMIT;
   ```

5. **回滚事务**（Rollback Transaction）：如果在事务中的任何操作失败，你可以使用 `ROLLBACK` 语句来回滚事务，撤销所有更改，使数据库恢复到事务开始之前的状态。

   ```sql
   ROLLBACK;
   ```

完整的示例事务操作如下：

```sql
START TRANSACTION;

-- 执行一系列 SQL 操作
INSERT INTO users (name, email) VALUES ('John', 'john@example.com');
UPDATE orders SET status = 'shipped' WHERE order_id = 123;
-- 其他 SQL 操作

-- 检查操作是否成功
IF condition THEN
    ROLLBACK;
ELSE
    COMMIT;
END IF;
```

请注意，在 MySQL 中，事务通常用于存储引擎支持事务的表，如 InnoDB。如果你不使用支持事务的存储引擎，事务操作可能不会生效。确保你的表使用正确的存储引擎，并在需要时使用事务来维护数据一致性。

#### 5.3 并发事务问题

- **脏读（Dirty Read）**：
  - 脏读发生在一个事务读取了另一个事务尚未提交的数据。如果那个事务之后回滚了，读取的数据将是无效的。
  - 这是因为一个事务可以读取其他事务的临时修改，导致不一致的数据。
- **不可重复读（Non-Repeatable Read）**：
  - 不可重复读发生在同一事务中的两次读取操作之间，第二次读取返回不同的结果。这可能是因为另一个事务在两次读取之间修改了数据。
  - 这种情况下，数据的一致性受到了破坏，因为同一事务的两次读取操作得到了不同的数据。
- **幻读（Phantom Read）**：
  - 幻读发生在同一事务的两次查询之间，第二次查询返回了不同数量的行，尽管数据没有被其他事务修改或删除。
  - 幻读通常与范围查询相关，当事务在两次查询之间的时间窗口内插入新行或删除行时，会导致幻读问题。



#### 5.4 事务的隔离级别

- | 隔离级别         | 脏读 | 不可重复读 | 幻读 |
  | ---------------- | ---- | ---------- | ---- |
  | Read Uncommitted | 允许 | 允许       | 允许 |
  | Read Committed   | 禁止 | 允许       | 允许 |
  | Repeatable Read  | 禁止 | 禁止       | 允许 |
  | Serializable     | 禁止 | 禁止       | 禁止 |

  1. **Read Uncommitted（读未提交）**：
     - 最低的隔离级别，它允许事务读取其他事务尚未提交的数据。这导致脏读问题。
     - 不会阻止其他事务修改数据，因此也可能导致不可重复读和幻读问题。
  2. **Read Committed（读已提交）**：
     - 读已提交隔离级别禁止事务读取其他事务尚未提交的数据，因此避免了脏读问题。
     - 不可重复读和幻读问题仍然可能发生，因为其他事务可以在同一事务执行期间提交更改。
  3. **Repeatable Read（可重复读，通常是默认隔离级别）**：
     - Repeatable Read 隔离级别禁止事务读取其他事务尚未提交的数据，避免了脏读和不可重复读问题。
     - 仍然可能发生幻读问题，因为其他事务可以在同一事务执行期间插入新数据。
  4. **Serializable（串行化）**：
     - 最高的隔离级别，它通过**锁定数据表**来确保数据的完全一致性，避免了脏读、不可重复读和幻读问题。
     - Serializable 隔离级别通常会降低系统的并发性能，因为它会引入更多的锁定和等待。

  在选择隔离级别时，需要权衡数据一致性和性能。通常，低隔离级别可以提供更高的性能，但可能会牺牲数据一致性，而高隔离级别可以提供更好的数据一致性，但可能会降低性能。选择正确的隔离级别取决于应用程序的需求和特定的数据库工作负载。





### 6. 索引

以下是创建这些索引类型的通用语法：

1. **唯一索引（UNIQUE INDEX）**：唯一索引确保索引列的值在表中是唯一的，不允许重复值。

   ```sql
   CREATE UNIQUE INDEX index_name
   ON tbl_name (index_col_name, ...);
   ```

2. **全文索引（FULLTEXT INDEX）**：全文索引用于在文本数据上执行全文搜索，通常用于搜索引擎和文本分析。

   ```sql
   CREATE FULLTEXT INDEX index_name
   ON tbl_name (index_col_name, ...);
   ```

3. **空间索引（SPATIAL INDEX）**：空间索引用于处理地理空间数据，例如地理信息系统（GIS）中的地理坐标数据。

   ```sql
   CREATE SPATIAL INDEX index_name
   ON tbl_name (index_col_name, ...);
   ```

在上述语法中，你需要替换以下部分：

- `index_name`：索引的名称，你可以为索引选择一个描述性的名称。
- `tbl_name`：要创建索引的表名。
- `index_col_name`：一个或多个要包含在索引中的列名。根据索引类型，这些列可以是唯一索引、全文索引或空间索引的列。





# 面试

## 1. 索引篇

目录，

索引，

