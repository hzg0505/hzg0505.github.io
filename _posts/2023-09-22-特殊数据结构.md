---
title: 特殊数据结构
date: 2023-09-21 15:30:00 +0800
categories: [学习笔记, 数据结构]
# toc: false
tags: [c++, 数据结构]     # TAG names should always be lowercase
---



### 1. 二叉树、B数、B+ 树

- 二分查找  => 对数据进行排序
- 二叉搜索树（BST）

- 平衡二叉树（AVL）：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1

- 红黑树：

  - 条件
    - 根节点是黑色的。
    - 所有的叶子节点都是黑色的，并且不存储任何数据（空节点）。
    - 如果一个节点是红色的，那么它的左右子节点都是黑色的。
    - 对于每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。

  - 红黑树能够保持平衡，并且任意节点的左右子树深度差不会超过2，这使得它在插入、删除等操作时，相比普通的二叉搜索树，**旋转操作大大减少，从而提高了操作的效率**。

- b树（B-tree）
  - 平衡多路查找树 （M路）
    - 左小右大（逻辑大小）
    - 关键字数：[ceil(M/2)-1, M-1]
    - 所有叶子节点均在同一层、叶子节点除了包含了关键字 和 关键字记录的指针外，也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子;
  - B树相对平衡二叉树在节点空间的利用率上进行改进，B树在每个节点保存更多的数据，减少了树的高度，从而提升了查找的性能，在数据库应用中，B树的每个节点存储的数据量大约为4K, 这是因为考虑到磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次对磁盘进行IO数据读取时，同一个磁盘块的数据会被一次性读取出来，所以每一次磁盘IO都可以读取到B树中一个节点的全部数据。
- B+树
  - 非叶子结点不保存具体的数据，只保存关键字的索引，数据全保存在叶子结点中。（查询需要找到叶子结点，查询速度稳定）
    - 数据库的应用层，B+树更合适
  - 叶子结点关键字从小到大排序，（链表）
- **B+树和B树的对比**
  - B+**树查询速度更稳定**：B+所有关键字数据地址都存在**叶子**节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定。
  - B+**树天然具备排序功能：**B+树所有的**叶子**节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。
  - B+**树全节点遍历更快：**B+树遍历整棵树只需要遍历所有的**叶子**节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。
  - **B树**相对于**B+树**的优点是，如果经常访问的数据离根节点很近，而**B树**的**非叶子**节点本身存有关键字和数据，所以在查询这种数据检索的时候会要比**B+树**快。



### 2. 跳表（skip list）

[简书：Skip List--跳表](https://www.jianshu.com/p/9d8296562806)

- 有序单链表 
  - 查找效率很低 O(n)
  - ![跳表：原始链表](/assets/figs/数据结构/webp0.png)
  - ![跳表：一级索引](/assets/figs/数据结构/webp1.png)
  - ![跳表：二级索引](/assets/figs/数据结构/webp2.png)

- 跳表
  - 查找：时间复杂度=索引的高度*每层索引便利元素的个数 跳表高度 $h=log_2n$

### 3. 红黑树

[简书：安卓大叔](https://www.jianshu.com/p/e136ec79235c)

- 性质

  - 性质1：每个节点要么是黑色，要么是红色。
- 性质2：根节点是黑色。
  - 性质3：每个叶子节点（NIL）是黑色。
- 性质4：每个红色结点的两个子结点一定都是黑色。
  - **性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。**




### 4. 堆

- 基本性质
  - 一种完全二叉树（有时候并不一定 Fibonacci 堆）
  - **最大堆**：在最大堆中，父节点的值总是大于或等于其子节点的值，因此根节点包含堆中的最大元素。
  - **最小堆**：在最小堆中，父节点的值总是小于或等于其子节点的值，因此根节点包含堆中的最小元素。
  - 有序的：查找、插入、删除 效率较高
- 常见操作
  - 插入（Insertion）：将一个新元素添加到堆中。
  - 删除最大或最小元素（Extraction）：从堆中删除并返回根节点，即最大或最小元素。
  - 建堆（Heapify）：将一个无序数组转换为堆结构，通常是从底部向上或从顶部向下进行调整。
  - 堆排序（Heap Sort）：使用堆进行排序。
- 应用
  - 优先队列
  - Dijkstra 算法
  - 堆排序
  - 快速查找最大或最小值
- 时间复杂度：插入删除 O(logn)
