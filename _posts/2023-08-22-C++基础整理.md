---
title: C++ 基础整理
date: 2023-08-22 11:45:00 +0800
categories: [学习笔记, C++]
# toc: false
tags: [c++]     # TAG names should always be lowercase
---

# 一、C++ 写在前面
### 1. 为什么学 C++

- **性能 = 金钱**：C++ 因其高性能而受欢迎。高性能编程语言在以下方面可以带来金钱的节省和效益：

  - **耗电**：高性能的程序通常需要更少的计算资源，因此在移动设备上运行时可以降低电池消耗。
  - **资源**：C++ 可以更有效地管理内存和其他计算资源，这意味着更少的资源浪费和更低的硬件要求。
  - **体验**：高性能的应用程序通常具有更快的响应时间，提供更流畅的用户体验，这有助于吸引和保留用户。

- **高性能的编程语言需要**：要创建高性能的应用程序，需要编程语言具备以下特性：

  - **计算效率**：C++ 可以生成高效的机器代码，这使得它非常适合需要快速运行的应用程序。
  - **编程灵活**：C++ 提供了丰富的编程工具和语言特性，允许程序员更好地控制代码的执行方式。
  - **抽象**：C++ 允许使用抽象数据类型和面向对象编程的概念，这有助于更清晰地组织和管理代码。
  - **生产力**：C++ 提供了强大的标准库，可以加速开发过程，提高生产力。

  > 与之相比，Java 更注重开发速度和跨平台兼容性，而不是极致性能。

- **其他**：

  - **C++ 应用范围广泛**：C++ 不仅适用于高性能计算、嵌入式系统和游戏开发等领域，还在金融、科学计算和操作系统开发等各种应用中广泛使用。学习C++可以使你在多个领域都具备有价值的技能。

学习C++是因为它的高性能可以在节省金钱、能源和提供更好用户体验的同时，强调计算效率、编程灵活性、抽象能力以及生产力，而且C++的广泛应用领域使其成为一门有价值的编程语言。

### 2. C++为什么难学

- **C++ 之父的设计哲学**：C++ 的设计目标包括提供更好的 C 语言，同时引入了许多新的特性，如数据抽象、面向对象编程和泛型编程，这些新特性增加了学习的复杂性。
- **多重编程范式支持**：C++ 支持多种编程范式，包括过程式、数据抽象、基于对象、面向对象、函数式、泛型形式和模板元编程。这意味着学习者需要理解和掌握不同的编程思维方式，以便有效地使用这些范式来解决问题。
- **值语义与对象语义**：C++ 引入了值语义和对象语义的概念。值语义意味着可以拷贝和赋值对象，而对象语义意味着不可以拷贝和赋值对象。这种区分增加了对对象生命周期和内存管理的复杂性，需要学习者更深入地理解C++的语义。

C++的复杂性源于其丰富的特性、编程范式和语义，使得学习者需要投入更多的时间和精力来掌握这门语言。然而，一旦掌握了C++，它也能提供广泛的编程能力和灵活性，使程序员能够解决各种复杂的问题。

### 3. c++ 编程书籍推荐

- C++ primer

- Effective C++ 3rd
- C++ 编程规范
- 代码大全，第二版
- ~~c++ 高质量编程  （不推荐、讲排版上的规范）~~



# 二、从 c 到 c++ 

 

区 块 (b l o c k s ) 、 语 句 ( s t a t e m e n t s ) 、 预 处 理 器 (p r e p r o c e s s o r ) 、 内 置 数 据 类 型 (b u i l t - i n d a t a t y p e s ) 、 数 组 ( a r r a y s ) 、 指针 (pointers)等统统来自C

### 1. 数据类型

- **类（Class）**：类是C++中最重要的新增数据类型之一。它允许程序员创建自定义的复合数据类型，其中包含数据成员和成员函数。类的实例被称为对象，这使得面向对象编程成为可能。

- **结构体（Struct）**：结构体在C++中与C语言中的结构体类似，但C++允许在结构体中添加成员函数和访问控制修饰符，从而使其更接近类的特性。结构体在C++中也可以包含构造函数和析构函数。

- **模板（Template）**：模板是一种通用的数据类型，允许编写可以处理不同数据类型的通用代码。C++中的模板可用于创建通用函数和类，这是泛型编程的基础。

- **标准库容器类型**：C++标准库提供了一系列容器类型，如向量（vector）、列表（list）、队列（queue）、堆栈（stack）等。这些容器提供了不同的数据存储和操作方式，使程序员能够更轻松地管理数据集合。

- **引用（Reference）**：引用是C++中的一种新增的数据类型，允许在不复制数据的情况下使用另一个变量的别名。引用用于创建函数的别名参数和其他情况，有助于提高性能和代码可读性。

- **布尔类型（bool）**：C++引入了布尔类型，允许表示逻辑值，只有两个可能的值：true和false。这在条件语句和逻辑运算中非常有用。

- **枚举类型（enum）**：虽然枚举类型在C语言中也存在，但C++中的枚举类型更加强大。C++允许为枚举类型赋予具体的整数值，也可以指定枚举类型的底层数据类型。

- **wchar_t类型**：这是一种宽字符类型，用于处理Unicode字符和国际化字符串。

这些新增的数据类型使C++比C语言更适合于面向对象编程、泛型编程和数据结构操作等任务，增强了语言的表达能力和灵活性。这些数据类型与C语言中的数据类型一起构成了C++的丰富类型系统。

---



### 2. `const` VS `#define` 

- **类型和内存分配**：

  - `const` 定义的常量有数据类型，而 `#define` 定义的符号常量没有数据类型。这意味着 `const` 常量具有类型安全性，编译器可以进行类型检查。

  - `const` 常量在编译时分配内存，而 `#define` 符号常量在预处理时进行文本替换，不分配内存。

- **作用域**：
  - `const` 常量有作用域，它们只在其定义的作用域内有效。这可以帮助避免命名冲突和提高代码的可维护性。
  
  - `#define` 符号常量在整个文件范围内有效，容易引起命名冲突。
  
- **最佳实践**：

  - 尽量使用 `const` 和 `enum` 来定义常量，因为它们提供了类型安全和作用域控制。

  - 对于高层次编程，推荐使用 `const` 和 `enum` 替代 `#define`，以提高代码的可读性和可维护性，也可以使用 `inline` 函数来定义常量函数。

  - 在底层编程时，`#define` 可以提供更大的灵活性，例如用于条件编译、宏定义和编译器标志等。

总之，使用 `const` 和 `enum` 更有助于编写类型安全、可维护且清晰的代码。在高级别编程中，这些是更好的选择。然而，在一些特殊情况下，如底层编程和需要宏定义的地方，`#define` 可能仍然是有用的。选择适当的方式取决于你的编程需求和风格。

```c++
// 常量
// 1. 定义时需初始化
// 2. 不可修改
// 3. 指针常量/常量指针

#include <iostream>
using namespace std;
int main(void){
    // 1.（常量定义必须初始化）
    // const int a;      // error 常量 变量 "a" 需要初始值设定项C/C++(257)
    const int a=1;
    // a = 2;            // error 表达式必须是可修改的左值C/C++(137) 不可重新被赋值
    cout << a << endl;

    // 2. int const * p     指针常量，pointer to a constant 指针指向内容为常量   //  =》3.26
    int b = 2;
    const int *p;   // const 在 * 左边 *p为常量，指向的内容不可变, 指针可指向其他内容
    cout << *p << endl;   // 指针指向内容随机指向
    p = &a;
    // *p = b;      // error 不能更改指向内容
    cout << *p << endl;
    p = &b;         // 可更改指向
    cout << *p << endl;

    // 3. int * const q     常量指针 constant pointer 指针为常量，内容可变
    int c = 3;
    int * const q=&c;  // q 为常量 得初始化   常量指针，得赋值
    cout << *q << endl;
    // q = &b;            // error  q指针为常量 不能重新赋值
    c = 4;
    cout << *q << endl;   // 指向内容可变化
    // const int *q;   // const 在 * 左边 *p为常量，指向的内容不可变, 指针可指向其他内容
    // q = &c;
    // c = 4;
    // cout << *p << endl;
}
```



```c++
// ## 运算符：这是一个标记粘合运算符，用于将两个标记（tokens）粘合在一起，创建一个新的标记。它通常用于宏定义中，以动态地生成标识符。
#define CONCATENATE(x, y) x ## y
int myVariable = 42;
int myVariable##2 = 24; // 这将生成一个名为 myVariable2 的变量
// 上述代码中，CONCATENATE 宏使用 ## 运算符将参数 x 和 y 粘合在一起，生成了一个新的标识符 myVariable2。

// # 运算符：这是字符串化运算符，用于将标记转化为字符串常量。它通常在宏定义中使用，以便将标识符转化为字符串。例如：
#define STRINGIFY(x) #x
const char* str = STRINGIFY(hello); // str 的值是 "hello"
//在这个例子中，STRINGIFY 宏使用 # 运算符将参数 x 转化为字符串常量。
```



### 3. `new`, `delete` 

| 特征           | `new`                            | `malloc`                                |
| -------------- | -------------------------------- | --------------------------------------- |
| 语言差异       | C++ 运算符                       | C 和 C++ 函数                           |
| 类型安全       | 是                               | 否                                      |
| 内存大小指定   | 不需要显式指定，根据类型自动计算 | 需要显式指定                            |
| 类型转换       | 不需要，返回与对象类型匹配的指针 | 需要类型转换                            |
| 构造和析构对象 | 自动调用构造函数和析构函数       | 不自动调用构造函数和析构函数            |
| 分配失败处理   | 引发异常（std::bad_alloc）       | 返回 NULL 指针                          |
| C++标准库集成  | 是                               | 否                                      |
| 示例           | `int* ptr = new int;`            | `int* ptr = (int*)malloc(sizeof(int));` |
| 示例的释放     | `delete ptr;`                    | `free(ptr);`                            |

- **`new` 运算符**：
  - `new` 运算符用于在堆上动态分配内存，它的主要作用是创建对象和数据结构。
  
  - `new` 成功时返回分配的内存的首地址，失败时抛出 `std::bad_alloc` 异常。
  
  - 语法：
    - `指针变量 = new 数据类型;`：用于创建一个数据类型的对象，并将其地址赋值给指针变量。
    - `指针变量 = new 数据类型[长度 n];`：用于创建 n 个数据类型的元素的数组，并将其地址赋值给指针变量。
  - **不同形式的 `new`**：
    - `operator new`：只进行内存分配，不调用构造函数。
    - `new operator`：分配内存并调用构造函数。
    - **placement new**：不分配内存，只调用构造函数。通常用于将对象放置在预先分配的内存块中。
  
- **`delete` 运算符**：

  - `delete` 运算符用于释放先前由 `new` 分配的堆内存，以防止内存泄漏。

  - 语法：
    - `delete 指针变量;`：用于释放单个对象或数据结构。
    - `delete[] 指针变量;`：用于释放数组对象或数据结构。

- **对象的 `new` 和 `delete`**：

  - 对于对象，`new` 运算符不仅分配内存，还会调用对象的构造函数来初始化对象。

  - 相反，`delete` 运算符会首先调用对象的析构函数，然后释放内存。

  - 这确保了在释放对象之前可以执行必要的清理操作。

总的来说，`new` 和 `delete` 运算符是C++中用于动态内存管理的重要工具，它们使程序能够有效地分配和释放内存，并与对象的生命周期紧密关联，以确保资源的正确管理。但需要小心使用它们，以避免内存泄漏和访问已释放内存的问题。

```c++
#include<iostream>
using namespace std;

int main()
{
    int *p = new int;         // 分配一个整数空间 4 字节
    cout << *p << endl;
    int *p1 = new int(33);    // 分配一个整数空间 初始值用圆括号
    cout << *p1 << endl;
    int *q = new int[10];     // 分配10个整数空间 10 字节   数组没办法初始化，需逐个初始化
    cout << *q << endl;

    // 销毁
    delete p;
    delete p1;
    delete[] q;
    return 0;
}
```



### 4. 域运算符 `::`

- **访问对局部变量同名的全局变量**：
  - 当在某个局部作用域中定义了与全局作用域中同名的变量时，局部变量会隐藏全局变量。这时，可以使用作用域解析运算符 `::` 来明确指定要访问的是全局变量。

```c++
int x = 10; // 全局变量 x
void myFunction() {
    int x = 5; // 局部变量 x
    std::cout << "局部变量 x：" << x << std::endl; // 访问局部变量 x
    std::cout << "全局变量 x：" << ::x << std::endl; // 访问全局变量 x
}
```

- **访问类的成员**：
  - 在类中，作用域解析运算符 `::` 用于访问类的静态成员变量和静态成员函数。这是因为静态成员与类相关联，而不是与类的对象相关联。

```c++
class MyClass {
public:
    static int x; // 静态成员变量
    static void myStaticFunction() { // 静态成员函数
        // 在静态成员函数中可以直接访问静态成员变量
        x = 42;
    }
};

int MyClass::x = 0; // 静态成员变量的定义和初始化

int main() {
    MyClass::myStaticFunction(); // 使用作用域解析运算符访问静态成员函数
    std::cout << "静态成员变量 x：" << MyClass::x << std::endl; // 使用作用域解析运算符访问静态成员变量
    return 0;
}
```

总之，作用域解析运算符 `::` 是C++中的一个重要工具，用于明确指定要访问的标识符位于哪个作用域中，以解决同名变量或访问类的静态成员的问题。



### 5. 函数重载

- 概念
  - 函数重载是指在相同的作用域内定义多个函数，这些函数的名称相同但参数列表不同。
  - 参数列表的不同形式可以包括参数数量不同、参数类型不同、参数顺序不同或参数数量和类型均不同。
  - 在调用重载函数时，编译器会根据实际传递的参数来选择匹配的函数，这个过程叫做函数重载解析（overload resolution）。
  - 函数重载允许你为不同的用例提供相似的接口，增强了代码的可读性和复用性。
- **函数多态性（Function Polymorphism）**：
  - 函数重载是函数多态性的一种表现形式，也叫做**静态多态性**。
  - 静态多态性是指在编译时根据函数的名称和参数列表来确定要调用的函数版本，因此在编译时已经确定了函数入口地址。
  - **动态多态性**（runtime polymorphism）是通过**虚函数**实现的，它在运行时确定要调用的函数版本，通常用于处理派生类的情况，以实现动态绑定（dynamic binding）。

- `extern "C"` 

  - 在C++中，默认情况下，编译器会对函数名进行名称修饰（name mangling），这是为了支持函数重载和C++的特性。这种修饰会使函数名在编译后变得更加复杂，这样就难以与纯C代码进行链接，因为C编译器不会进行这种修饰。

  - 当你使用 `extern "C"` 声明一个函数或函数指针时，C++编译器会告诉它不要对这个函数名进行名称修饰，使得这个函数能够与C代码进行兼容，并且可以正确地链接。这对于与纯C代码库进行互操作非常有用，例如在C++中调用C编写的函数，或者将C++代码编译为动态链接库（DLL）以供C代码使用。

  ```c++
  // C++ 代码
  extern "C" {
      void myCFunction(int x) {
          // 这里的代码可以调用C语言风格的函数
      }
  }
  ```

  - 在上面的示例中，`extern "C"` 声明告诉编译器 `myCFunction` 应该按照C语言的链接规则来处理，而不是C++的名称修饰规则。



### 6. 引用

- 概念
  - 引用是变量的**别名**，它**没有自己的内存空间**，与所引用的变量共享内存。
  - 引用在定义时**必须初始化**，并且初始化后不能重新指向其他变量。

- **const 引用**：
  - 对于 const 对象而言，要引用只能使用 const 引用 （保护机制）
  - 对于 非const 对象而言
    - 使用 const 引用后，不能通过引用更改  （主要用途，传递对象给函数，函数不会修改对象）
    - 使用 普通 引用无法引用不同类型的对象   

```c++
#include <iostream>
using namespace std;
int main(){
  	// 1. const引用 绑定到 const对象，非const引用不能绑定到 const对象
    const int val = 100;
    // int& ref2_val = val;  // error 将 "int &" 类型的引用绑定到 "const int" 类型的初始值设定项时，限定符被丢弃C/C++(433)
    const int& ref_val = val;
		
  	// 2. 不能通过引用更改
    int val2 = 200;
    const int& ref_val2 = val2;   
    // ref_val2 = 100;       // error 表达式必须是可修改的左值C/C++(137)
    val2 = 100;
    cout << val2 << endl;
		
  	// 3， const 引用指向不同类型变量
    double val3 = 3.14;
    const int& ref_val3 = val3;   // 会产生一个临时变量
                                  // int temp=val3;
                                  // const int& ref_val3 = temp;
  																// val3 变化后 ref_val3 仍为 temp
    cout << val3 << endl;
    cout << ref_val3 << endl;
    // 非 const 引用无法指向不同类型的对象
    // int& ref2_val3 = val3;    // error 无法用 "double" 类型的值初始化 "int &" 类型的引用(非常量限定)C/C++(434)

    return 0;
}
```

- **引用传递**：

  - 概念：
    - 引用传递是一种将参数传递给函数的方式，通过在函数定义中使用引用运算符 `&` 来实现。
    - 引用传递允许函数修改传递的参数，因为它们直接引用了原始对象，而不是创建副本。
  - 函数参数传递
    - 值传递：函数接收参数的副本，不能修改原始值。
    - 指针传递：函数接收参数的地址，可以修改原始值。
    - 引用传递：函数接收参数的引用，可以修改原始值。

  - **引用作为函数返回值**：
    - 函数可以返回引用，这样函数的返回值就是原始对象的引用。
    
    - 返回引用的函数通常用于链式操作，如 `a = b = c`。
    
    - 不能返回指向局部变量的引用，因为局部变量的生命周期在函数结束时结束。
    
  - 悬垂引用是一种常见的错误，因为它会导致未定义行为。为了避免悬垂引用，应该遵循以下原则：
    - 不要返回指向局部变量的引用。
    - 在删除对象后，不要再使用指向该对象的引用。
    - 引用的生命周期应该始终在引用的对象的生命周期内。